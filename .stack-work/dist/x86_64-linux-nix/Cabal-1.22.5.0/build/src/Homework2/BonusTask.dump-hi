
==================== FINAL INTERFACE ====================
2016-09-10 20:22:33.581113 UTC

interface itmoh_AgUyFMR0A7v8PCeJbbIyvY:Homework2.BonusTask 7103
  interface hash: 1276cabe121d1039bcdeca8c0e17bb6e
  ABI hash: e803b45af6a22d3571a075d22960bec0
  export-list hash: 507c6f7c25b77c59555e3da8485bf1c4
  orphan hash: 240fdd4dd879d47a282812c6bf633155
  flag hash: 04202c81f1977d75b6853c743de39f6b
  sig of: Nothing
  used TH splices: False
  where
exports:
  Homework2.BonusTask.extractMin
  Homework2.BonusTask.fromList
  Homework2.BonusTask.getMinimum
  Homework2.BonusTask.insert
  Homework2.BonusTask.merge
  Homework2.BonusTask.singleton
  Homework2.BonusTask.toList
  Homework2.BonusTask.BinHeap
  Homework2.BonusTask.BinNode{Homework2.BonusTask.BinNode Homework2.BonusTask.children Homework2.BonusTask.degree Homework2.BonusTask.key}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.Function 6b13a8d3a5e3bd757a91434dce3fc7f3
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Ord 66127262fc269c8a61d7d87ba94bd4d2
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
ee9628e3707ca728d7c3ab656668dc4a
  $sconcatMap :: (a3 -> [b]) -> [a3] -> [b]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a3 @ b f :: a3 -> [b] xs :: [a3] ->
                 GHC.Base.build
                   @ b
                   (\ @ b1 c :: b -> b1 -> b1[OneShot] n :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ a3
                      @ b1
                      (\ x :: a3 b2 :: b1[OneShot] -> GHC.Base.foldr @ b @ b1 c b2 (f x))
                      n
                      xs)) -}
af72e71cf2dd4d9ea98d01a5078c0790
  $wextractMin ::
    GHC.Classes.Ord a =>
    Homework2.BonusTask.BinHeap a
    -> (# a, Homework2.BonusTask.BinHeap a #)
  {- Arity: 2,
     Strictness: <L,U(1*U,C(C1(U)),C(C1(U)),A,A,A,A,A)><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a1
                   w :: GHC.Classes.Ord a1
                   w1 :: Homework2.BonusTask.BinHeap a1 ->
                 case w1 of wild {
                   []
                   -> case Homework2.BonusTask.extractMin2
                      ret_ty (# a1, Homework2.BonusTask.BinHeap a1 #)
                      of {}
                   : ipv ipv1
                   -> let {
                        minNode :: Homework2.BonusTask.BinNode a1
                        = letrec {
                            go :: [Homework2.BonusTask.BinNode a1]
                                  -> Homework2.BonusTask.BinNode a1
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ ds :: [Homework2.BonusTask.BinNode a1] ->
                              case ds of wild1 {
                                [] -> Homework2.BonusTask.extractMin1 @ a1
                                : x ds1
                                -> case ds1 of wild2 {
                                     [] -> x
                                     : ipv2 ipv3
                                     -> let {
                                          y :: Homework2.BonusTask.BinNode a1 = go wild2
                                        } in
                                        case GHC.Classes.compare
                                               @ a1
                                               w
                                               (case x of wild3 { Homework2.BonusTask.BinNode ds2 ds3 ds4 ->
                                                ds2 })
                                               (case y of wild3 { Homework2.BonusTask.BinNode ds2 ds3 ds4 ->
                                                ds2 }) of wild3 {
                                          DEFAULT -> x GHC.Types.GT -> y } } }
                          } in
                          go wild
                      } in
                      (# case minNode of wild1 { Homework2.BonusTask.BinNode ds ds1 ds2 ->
                         ds },
                         case minNode of wild1 { Homework2.BonusTask.BinNode ds ds1 ds2 ->
                         Homework2.BonusTask.merge
                           @ a1
                           w
                           ds1
                           (Data.OldList.deleteBy
                              @ (Homework2.BonusTask.BinNode a1)
                              (let {
                                 a2 :: GHC.Classes.Eq a1 = GHC.Classes.$p1Ord @ a1 w
                               } in
                               let {
                                 .*. :: a1 -> a1 -> GHC.Types.Bool = GHC.Classes.== @ a1 a2
                               } in
                               \ x :: Homework2.BonusTask.BinNode a1
                                 y :: Homework2.BonusTask.BinNode a1[OneShot] ->
                               .*.
                                 (case x of wild2 { Homework2.BonusTask.BinNode ds3 ds4 ds5 ->
                                  ds3 })
                                 (case y of wild2 { Homework2.BonusTask.BinNode ds3 ds4 ds5 ->
                                  ds3 }))
                              wild1
                              wild) } #) }) -}
e76aa2efd55e6d4907bb13fba60f8f61
  type BinHeap a = [Homework2.BonusTask.BinNode a]
e76aa2efd55e6d4907bb13fba60f8f61
  data BinNode a
    = BinNode {key :: a,
               children :: Homework2.BonusTask.BinHeap a,
               degree :: GHC.Types.Int}
    RecFlag: Recursive
cd2c98cd322c8b278a1f6d9b015eacae
  children ::
    Homework2.BonusTask.BinNode a -> Homework2.BonusTask.BinHeap a
  RecSel Homework2.BonusTask.BinNode
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 ds :: Homework2.BonusTask.BinNode a1 ->
                 case ds of wild { Homework2.BonusTask.BinNode ds1 ds2 ds3 ->
                 ds2 }) -}
f4a790c2aa5841cc7e0a5bde203fdef5
  degree :: Homework2.BonusTask.BinNode a -> GHC.Types.Int
  RecSel Homework2.BonusTask.BinNode
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 ds :: Homework2.BonusTask.BinNode a1 ->
                 case ds of wild { Homework2.BonusTask.BinNode ds1 ds2 ds3 ->
                 ds3 }) -}
c8ed13f8669b960fc067b059a92c373c
  extractMin ::
    GHC.Classes.Ord a =>
    Homework2.BonusTask.BinHeap a -> (a, Homework2.BonusTask.BinHeap a)
  {- Arity: 2,
     Strictness: <L,U(1*U,C(C1(U)),C(C1(U)),A,A,A,A,A)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a1
                   w :: GHC.Classes.Ord a1
                   w1 :: Homework2.BonusTask.BinHeap a1 ->
                 case Homework2.BonusTask.$wextractMin
                        @ a1
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
9f8752b7a700f9e1b10d5018c7944a1a
  extractMin1 :: Homework2.BonusTask.BinNode a
  {- Strictness: b -}
bd832e207dbd8320007f6ddfc131d49b
  extractMin2 :: (a, Homework2.BonusTask.BinHeap a)
  {- Strictness: b -}
45787758c9d6d3ed1a04782217aae9c6
  fromList ::
    GHC.Classes.Ord a => [a] -> Homework2.BonusTask.BinHeap a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a1 $dOrd :: GHC.Classes.Ord a1 eta :: [a1] ->
                 letrec {
                   go :: [a1] -> Homework2.BonusTask.BinHeap a1
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [a1] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (Homework2.BonusTask.BinNode a1)
                       : y ys
                       -> Homework2.BonusTask.merge
                            @ a1
                            $dOrd
                            (GHC.Types.:
                               @ (Homework2.BonusTask.BinNode a1)
                               (Homework2.BonusTask.BinNode
                                  @ a1
                                  y
                                  (GHC.Types.[] @ (Homework2.BonusTask.BinNode a1))
                                  Homework2.BonusTask.fromList1)
                               (GHC.Types.[] @ (Homework2.BonusTask.BinNode a1)))
                            (go ys) }
                 } in
                 go eta) -}
b6c2b18b47d93a22dab069d7abda2e28
  fromList1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
5db58c7a71654fb8bb7964f20e1e5f72
  getMinimum ::
    GHC.Classes.Ord a => Homework2.BonusTask.BinHeap a -> a
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,A,A,1*U)><S,1*U>,
     Unfolding: (\ @ a1
                   $dOrd :: GHC.Classes.Ord a1
                   eta :: Homework2.BonusTask.BinHeap a1 ->
                 case GHC.Base.map
                        @ (Homework2.BonusTask.BinNode a1)
                        @ a1
                        (Homework2.BonusTask.key @ a1)
                        eta of wild {
                   [] -> Homework2.BonusTask.getMinimum1 @ a1
                   : ipv ipv1
                   -> let {
                        k :: a1 -> a1 -> a1 = GHC.Classes.min @ a1 $dOrd
                      } in
                      letrec {
                        go :: [a1] -> a1 -> a1 {- Arity: 2, Strictness: <S,1*U><L,U> -}
                        = \ ds :: [a1] eta1 :: a1 ->
                          case ds of wild1 { [] -> eta1 : y ys -> go ys (k eta1 y) }
                      } in
                      go ipv1 ipv }) -}
1fe583041b6f116b1cff530e9c368779
  getMinimum1 :: a
  {- Strictness: b -}
771bb49519d7ec0d229c2b10e24a532f
  insert ::
    GHC.Classes.Ord a =>
    a -> Homework2.BonusTask.BinHeap a -> Homework2.BonusTask.BinHeap a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A,A)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   $dOrd :: GHC.Classes.Ord a1
                   eta :: a1
                   eta1 :: Homework2.BonusTask.BinHeap a1 ->
                 Homework2.BonusTask.merge
                   @ a1
                   $dOrd
                   (GHC.Types.:
                      @ (Homework2.BonusTask.BinNode a1)
                      (Homework2.BonusTask.BinNode
                         @ a1
                         eta
                         (GHC.Types.[] @ (Homework2.BonusTask.BinNode a1))
                         Homework2.BonusTask.fromList1)
                      (GHC.Types.[] @ (Homework2.BonusTask.BinNode a1)))
                   eta1) -}
4b02b41cc906ab46dbea5805ee41f672
  key :: Homework2.BonusTask.BinNode a -> a
  RecSel Homework2.BonusTask.BinNode
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 ds :: Homework2.BonusTask.BinNode a1 ->
                 case ds of wild { Homework2.BonusTask.BinNode ds1 ds2 ds3 ->
                 ds1 }) -}
7628e6da18e17a4d0ed81bd87b8c4470
  merge ::
    GHC.Classes.Ord a =>
    Homework2.BonusTask.BinHeap a
    -> Homework2.BonusTask.BinHeap a -> Homework2.BonusTask.BinHeap a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U> -}
8356fd1cfcb602f94849935988accc81
  singleton :: a -> Homework2.BonusTask.BinHeap a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ @ a1 a2 :: a1 ->
                 GHC.Types.:
                   @ (Homework2.BonusTask.BinNode a1)
                   (Homework2.BonusTask.BinNode
                      @ a1
                      a2
                      (GHC.Types.[] @ (Homework2.BonusTask.BinNode a1))
                      Homework2.BonusTask.fromList1)
                   (GHC.Types.[] @ (Homework2.BonusTask.BinNode a1))) -}
18809355631246e32f9a7d8dcf100835
  toList :: Homework2.BonusTask.BinHeap a -> [a]
  {- Arity: 1, HasNoCafRefs -}
"SPEC/Homework2.BonusTask concatMap _ _ @ []" [ALWAYS] forall @ a3
                                                              @ b
                                                              $dFoldable :: Data.Foldable.Foldable
                                                                              []
  Data.Foldable.concatMap @ a3 @ b @ [] $dFoldable
  = Homework2.BonusTask.$sconcatMap @ a3 @ b
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

